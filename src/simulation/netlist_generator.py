# src/simulation/netlist_generator.py
from pathlib import Path
from typing import List, Tuple, Optional, Dict
from dataclasses import dataclass
import re

@dataclass
class SimulationConfig:
    """Configuration de simulation"""
    vdd: float = 1.8
    temp: float = 27
    corner: str = "tt"  # tt, ff, ss, sf, fs
    cload: float = 10e-15  # 10fF
    trise: float = 100e-12  # 100ps
    tfall: float = 100e-12

@dataclass
class TransitionTest:
    """DÃ©finit un test de transition"""
    name: str
    input_signals: Dict[str, str]  # {"A": "0â†’1", "B": "0"}
    measures: List[str]

class NetlistGenerator:
    """GÃ©nÃ¨re des netlists SPICE pour caractÃ©risation"""

    def __init__(self, pdk_manager, output_dir: Optional[Path] = None):
        self.pdk = pdk_manager
        
        # Par dÃ©faut, gÃ©nÃ©rer dans ngspice/
        if output_dir is None:
            self.output_dir = self.pdk.pdk_root / "libs.tech" / "ngspice"
        else:
            self.output_dir = Path(output_dir)
            
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Chemin vers la bibliothÃ¨que SPICE complÃ¨te
        self.lib_spice = self.pdk.pdk_root / "libs.ref" / "sky130_fd_sc_hd" / "spice" / "sky130_fd_sc_hd.spice"

    def _parse_transition(self, signal: str) -> Tuple[str, str]:
        """
        Parse une transition "0â†’1" ou "1" 
        Returns: (type, initial_value) oÃ¹ type = 'static', 'rise', 'fall'
        """
        if "â†’" in signal:
            parts = signal.split("â†’")
            if parts[0] == "0" and parts[1] == "1":
                return ("rise", "0")
            elif parts[0] == "1" and parts[1] == "0":
                return ("fall", "1")
        return ("static", signal)

    def generate_delay_netlist(
        self, 
        cell_name: str,
        config: SimulationConfig,
        transitions: Optional[List[TransitionTest]] = None
    ) -> Path:
        """GÃ©nÃ¨re une netlist de caractÃ©risation des dÃ©lais"""
        
        output_file = self.output_dir / f"{cell_name}_delay.spice"
        
        if transitions is None:
            transitions = self._generate_default_transitions(cell_name)
        
        ports = self._get_cell_ports(cell_name)
        input_pins = ports['inputs'].split()
        output_pin = ports['output']
        
        netlist_lines = [
            f"* Delay Characterization: {cell_name}",
            f"* Generated by NetlistGenerator",
            f"* Corner: {config.corner}, VDD={config.vdd}V, Temp={config.temp}Â°C",
            "",
            "* ===== CONVERGENCE OPTIONS =====",
            ".option reltol=1e-3",
            ".option abstol=1e-12",
            ".option vntol=1e-6",
            ".option gmin=1e-15",
            ".option method=gear",
            "",
            "* ===== PDK LIBRARY =====",
            f".lib sky130.lib.spice {config.corner}",
            "",
            "* ===== CELL LIBRARY =====",
            f".include {self.lib_spice}",
            "",
            "* ===== PARAMETERS =====",
            f".param SUPPLY={config.vdd}",
            f".param CLOAD={config.cload}",
            f".param trise={config.trise}",
            f".param tfall={config.tfall}",
            "",
            "* Temperature",
            f".temp {config.temp}",
            "",
            "* Power supplies",
            "VVDD VPWR 0 DC {SUPPLY}",
            "VVSS VGND 0 DC 0",
            "VVPB VPB 0 DC {SUPPLY}",
            "VVNB VNB 0 DC 0",
            "",
        ]

        # ===== CONDITION INITIALE: Premier Ã©tat stable =====
        first_test = transitions[0]
        initial_states = {}
        
        for pin in input_pins:
            if pin in first_test.input_signals:
                trans_type, initial = self._parse_transition(first_test.input_signals[pin])
                # Prendre la valeur AVANT la transition
                initial_states[pin] = "0" if trans_type == "rise" else initial
            else:
                initial_states[pin] = "0"
        
        netlist_lines.append("* Initial conditions for convergence")
        for pin, value in initial_states.items():
            voltage = "{SUPPLY}" if value == "1" else "0"
            netlist_lines.append(f".ic V({pin})={voltage}")
        
        netlist_lines.extend([
            "",
            "* Device Under Test",
            f"XCELL {' '.join(input_pins)} {output_pin} VPWR VGND VPB VNB {cell_name}",
            "",
            "* Output load",
            f"CL {output_pin} 0 {{CLOAD}}",
            "",
        ])

        # ParamÃ¨tres temporels
        test_duration = 2e-9  # 2ns par test
        settling_time = 1e-9  # 1ns entre tests
        total_time = len(transitions) * (test_duration + settling_time)
        
        # === NOUVELLE PARTIE: Construire les PWL en gardant l'Ã©tat ===
        
        # Dictionnaire pour stocker l'Ã©tat actuel de chaque pin
        pin_states = {pin: 0.0 for pin in input_pins}  # Tous dÃ©marrent Ã  0
        
        # Dictionnaire pour stocker les points PWL de chaque pin
        pwl_data = {pin: [(0, 0.0)] for pin in input_pins}  # t=0, tous Ã  0V
        
        for test_idx, test in enumerate(transitions):
            test_start = test_idx * (test_duration + settling_time)
            transition_time = test_start + 0.5e-9  # Transition au milieu du test
            
            for pin in input_pins:
                signal = test.input_signals.get(pin, None)
                
                if signal is None:
                    # Pin non spÃ©cifiÃ©: garder l'Ã©tat actuel
                    continue
                
                trans_type, target = self._parse_transition(signal)
                target_voltage = float(target) * config.vdd
                
                if trans_type == "static":
                    # VÃ©rifier si on doit changer l'Ã©tat
                    if pin_states[pin] != target_voltage:
                        # Ajouter transition instantanÃ©e au dÃ©but du test
                        pwl_data[pin].append((test_start, pin_states[pin]))
                        pwl_data[pin].append((test_start + 1e-12, target_voltage))
                        pin_states[pin] = target_voltage
                
                elif trans_type == "rise":
                    # S'assurer qu'on est bien Ã  0 avant
                    if pin_states[pin] != 0:
                        pwl_data[pin].append((test_start, pin_states[pin]))
                        pwl_data[pin].append((test_start + 1e-12, 0.0))
                    
                    # Ajouter la transition RISE
                    pwl_data[pin].append((transition_time, 0.0))
                    pwl_data[pin].append((transition_time + config.trise, config.vdd))
                    pin_states[pin] = config.vdd
                
                elif trans_type == "fall":
                    # S'assurer qu'on est bien Ã  VDD avant
                    if pin_states[pin] != config.vdd:
                        pwl_data[pin].append((test_start, pin_states[pin]))
                        pwl_data[pin].append((test_start + 1e-12, config.vdd))
                    
                    # Ajouter la transition FALL
                    pwl_data[pin].append((transition_time, config.vdd))
                    pwl_data[pin].append((transition_time + config.tfall, 0.0))
                    pin_states[pin] = 0.0
            
            # Maintenir l'Ã©tat jusqu'Ã  la fin du test
            test_end = test_start + test_duration
            for pin in input_pins:
                pwl_data[pin].append((test_end, pin_states[pin]))
        
        # GÃ©nÃ©rer les sources PWL
        netlist_lines.append("* Input sources")
        for pin in input_pins:
            pwl_str = " ".join([f"{t*1e9}n {v}" for t, v in pwl_data[pin]])
            netlist_lines.append(f"V{pin} {pin.lower()} 0 PWL({pwl_str})")
        
        netlist_lines.append("")
        
        # === MESURES: Utiliser index=1 pour chaque test ===
        threshold = config.vdd / 2
        
        for test_idx, test in enumerate(transitions):
            netlist_lines.append(f"* Test {test_idx + 1}: {test.name}")
            
            for measure in test.measures:
                # Simplement remplacer le threshold, garder RISE=1 et FALL=1
                adapted_measure = measure.replace("{SUPPLY/2}", str(threshold))
                netlist_lines.append(adapted_measure)
            
            netlist_lines.append("")

        # Simulation transient avec UIC (Use Initial Conditions)
        total_time = len(transitions) * (test_duration + settling_time)
        netlist_lines.extend([
            f"* Transient analysis",
            f".tran 1p {total_time} UIC",  # â† Ajout de UIC
            "",
            ".control",
            "run",
            ".endc",
            "",
            ".end"
        ])

        output_file.write_text("\n".join(netlist_lines))
        return output_file

    def _get_cell_ports(self, cell_name: str) -> dict:
        """Extrait les ports d'une cellule depuis la lib SPICE"""
        
        with open(self.lib_spice, 'r') as f:
            lines = f.readlines()
        
        # Chercher la ligne .subckt
        in_cell = False
        ports_lines = []
        
        for line in lines:
            line = line.strip()
            
            # DÃ©but de la cellule recherchÃ©e
            if line.lower().startswith(f'.subckt {cell_name.lower()}'):
                in_cell = True
                parts = line.split(maxsplit=2)
                if len(parts) > 2:
                    ports_lines.append(parts[2])
                continue
            
            # Ligne de continuation
            if in_cell and line.startswith('+'):
                ports_lines.append(line[1:].strip())
                continue
            
            # Fin de la cellule
            if in_cell:
                break
        
        if not ports_lines:
            raise ValueError(f"Cellule {cell_name} introuvable")
        
        # Parser les ports
        ports_text = ' '.join(ports_lines)
        all_ports = ports_text.split()
        
        # Retirer alimentation
        power_ports = {'VPWR', 'VGND', 'VPB', 'VNB', 'VDD', 'VSS'}
        signal_ports = [p for p in all_ports if p not in power_ports]
        
        if len(signal_ports) == 0:
            raise ValueError(f"Aucun port signal trouvÃ© pour {cell_name}")
        
        # Convention: dernier port = sortie
        output_port = signal_ports[-1]
        input_ports = signal_ports[:-1]
        
        # ðŸ”§ CAS SPÃ‰CIAL : Certaines cellules ont une sortie interne X
        # Pour BUF/AND/OR/XOR, la vraie sortie peut Ãªtre X au lieu de Y
        cell_lower = cell_name.lower()
        if any(gate in cell_lower for gate in ['buf', 'and', 'or', 'xor']):
            if 'X' in all_ports and 'Y' not in signal_ports:
                output_port = 'X'
        
        return {
            'inputs': ' '.join(input_ports),
            'output': output_port,
            'all_ports': all_ports,
            'input_list': input_ports
        }
 
    def _adapt_measure_indices(self, measure: str, transitions: List[TransitionTest], current_idx: int) -> str:
        """
        Calcule le bon index RISE/FALL en comptant les transitions prÃ©cÃ©dentes
        
        Args:
            measure: La mesure .meas
            transitions: Liste de tous les tests
            current_idx: Index du test actuel (0-based)
        """
        import re
        
        # Extraire le signal et le type de transition du TRIG
        trig_match = re.search(r'TRIG v\((\w+)\).*?(RISE|FALL)=1', measure, re.IGNORECASE)
        if not trig_match:
            return measure
        
        signal = trig_match.group(1).upper()
        edge_type = trig_match.group(2).upper()
        
        # Compter les transitions de ce type pour ce signal dans les tests prÃ©cÃ©dents
        edge_count = 1  # Le test actuel
        
        for i in range(current_idx):
            prev_test = transitions[i]
            if signal in prev_test.input_signals:
                trans_type, _ = self._parse_transition(prev_test.input_signals[signal])
                if (edge_type == "RISE" and trans_type == "rise") or \
                (edge_type == "FALL" and trans_type == "fall"):
                    edge_count += 1
        
        # Remplacer TRIG
        adapted = re.sub(
            r'(TRIG v\(\w+\).*?)(RISE|FALL)=1',
            rf'\1\2={edge_count}',
            measure,
            count=1,
            flags=re.IGNORECASE
        )
        
        # MÃªme chose pour TARG (signal de sortie)
        targ_match = re.search(r'TARG v\((\w+)\).*?(RISE|FALL)=1', adapted, re.IGNORECASE)
        if targ_match:
            # Pour la sortie, on compte aussi
            adapted = re.sub(
                r'(TARG v\(\w+\).*?)(RISE|FALL)=1',
                rf'\1\2={edge_count}',
                adapted,
                count=1,
                flags=re.IGNORECASE
            )
        
        return adapted

    def _generate_default_transitions(self, cell_name: str) -> List[TransitionTest]:
        """
        GÃ©nÃ¨re automatiquement les transitions Ã  tester selon le type de cellule
        
        Args:
            cell_name: Nom de la cellule
            
        Returns:
            Liste de TransitionTest
        """
        # Utiliser la nouvelle mÃ©thode avec auto-dÃ©tection
        return self._get_transition_tests(cell_name)

    def _get_transition_tests(self, cell_name: str) -> List[TransitionTest]:
        """GÃ©nÃ¨re les tests de transition pour une cellule donnÃ©e"""
        cell_lower = cell_name.lower()
        
        # Extraire les pins depuis le CDL
        pins = self.pdk.get_cell_pins(cell_name)
        inputs = [p for p in pins if p not in ['VPWR', 'VGND', 'VPB', 'VNB']]
        
        # Trouver la sortie (conventionnellement X, Y, Q ou derniÃ¨re pin)
        output_candidates = ['X', 'Y', 'Q', 'ZN', 'Z']
        output = next((p for p in output_candidates if p in inputs), None)
        if output:
            inputs.remove(output)
        else:
            output = inputs[-1]
            inputs = inputs[:-1]
        
        # Cellules Ã  1 entrÃ©e
        if len(inputs) == 1:
            inp = inputs[0]
            
            # INVERSEUR
            if 'inv' in cell_lower:
                return [
                    TransitionTest(
                        name=f"{inp}: 0â†’1 â†’ {output}: 1â†’0 (tphl)",
                        input_signals={inp: "0â†’1"},
                        measures=[
                            f".meas tran tphl TRIG v({inp.lower()}) VAL='{{SUPPLY/2}}' RISE=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' FALL=1"
                        ]
                    ),
                    TransitionTest(
                        name=f"{inp}: 1â†’0 â†’ {output}: 0â†’1 (tplh)",
                        input_signals={inp: "1â†’0"},
                        measures=[
                            f".meas tran tplh TRIG v({inp.lower()}) VAL='{{SUPPLY/2}}' FALL=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' RISE=1"
                        ]
                    )
                ]
            
            # BUFFER
            elif 'buf' in cell_lower:
                return [
                    TransitionTest(
                        name=f"{inp}: 0â†’1 â†’ {output}: 0â†’1 (tplh)",
                        input_signals={inp: "0â†’1"},
                        measures=[
                            f".meas tran tplh TRIG v({inp.lower()}) VAL='{{SUPPLY/2}}' RISE=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' RISE=1"
                        ]
                    ),
                    TransitionTest(
                        name=f"{inp}: 1â†’0 â†’ {output}: 1â†’0 (tphl)",
                        input_signals={inp: "1â†’0"},
                        measures=[
                            f".meas tran tphl TRIG v({inp.lower()}) VAL='{{SUPPLY/2}}' FALL=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' FALL=1"
                        ]
                    )
                ]
        
        # Cellules Ã  2 entrÃ©es
        elif len(inputs) == 2:
            a, b = inputs[0], inputs[1]
            
            # NAND
            if 'nand' in cell_lower:
                return [
                    TransitionTest(
                        name=f"{a}: 0â†’1, {b}=1 â†’ {output}: 1â†’0 (tphl)",
                        input_signals={a: "0â†’1", b: "1"},
                        measures=[
                            f".meas tran tphl TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' RISE=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' FALL=1"
                        ]
                    ),
                    TransitionTest(
                        name=f"{a}: 1â†’0, {b}=1 â†’ {output}: 0â†’1 (tplh)",
                        input_signals={a: "1â†’0", b: "1"},
                        measures=[
                            f".meas tran tplh TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' FALL=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' RISE=1"
                        ]
                    )
                ]
            
            # NOR
            elif 'nor' in cell_lower:
                return [
                    TransitionTest(
                        name=f"{a}: 0â†’1, {b}=0 â†’ {output}: 1â†’0 (tphl)",
                        input_signals={a: "0â†’1", b: "0"},
                        measures=[
                            f".meas tran tphl TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' RISE=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' FALL=1"
                        ]
                    ),
                    TransitionTest(
                        name=f"{a}: 1â†’0, {b}=0 â†’ {output}: 0â†’1 (tplh)",
                        input_signals={a: "1â†’0", b: "0"},
                        measures=[
                            f".meas tran tplh TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' FALL=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' RISE=1"
                        ]
                    )
                ]
            
            # AND
            elif 'and' in cell_lower and 'nand' not in cell_lower:
                return [
                    TransitionTest(
                        name=f"{a}: 0â†’1, {b}=1 â†’ {output}: 0â†’1 (tplh)",
                        input_signals={a: "0â†’1", b: "1"},
                        measures=[
                            f".meas tran tplh TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' RISE=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' RISE=1"
                        ]
                    ),
                    TransitionTest(
                        name=f"{a}: 1â†’0, {b}=1 â†’ {output}: 1â†’0 (tphl)",
                        input_signals={a: "1â†’0", b: "1"},
                        measures=[
                            f".meas tran tphl TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' FALL=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' FALL=1"
                        ]
                    )
                ]
            
            # OR
            elif 'or' in cell_lower and 'nor' not in cell_lower and 'xor' not in cell_lower:
                return [
                    TransitionTest(
                        name=f"{a}: 0â†’1, {b}=0 â†’ {output}: 0â†’1 (tplh)",
                        input_signals={a: "0â†’1", b: "0"},
                        measures=[
                            f".meas tran tplh TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' RISE=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' RISE=1"
                        ]
                    ),
                    TransitionTest(
                        name=f"{a}: 1â†’0, {b}=0 â†’ {output}: 1â†’0 (tphl)",
                        input_signals={a: "1â†’0", b: "0"},
                        measures=[
                            f".meas tran tphl TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' FALL=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' FALL=1"
                        ]
                    )
                ]
            
            # XOR
            elif 'xor' in cell_lower:
                return [
                    TransitionTest(
                        name=f"{a}: 0â†’1, {b}=0 â†’ {output}: 0â†’1 (tplh)",
                        input_signals={a: "0â†’1", b: "0"},
                        measures=[
                            f".meas tran tplh TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' RISE=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' RISE=1"
                        ]
                    ),
                    TransitionTest(
                        name=f"{a}: 1â†’0, {b}=0 â†’ {output}: 1â†’0 (tphl)",
                        input_signals={a: "1â†’0", b: "0"},
                        measures=[
                            f".meas tran tphl TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' FALL=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' FALL=1"
                        ]
                    )
                ]
        
        raise NotImplementedError(f"Type de cellule non supportÃ©: {cell_name} avec {len(inputs)} entrÃ©es")