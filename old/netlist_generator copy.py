# src/simulation/netlist_generator.py
from pathlib import Path
from typing import List, Tuple, Optional, Dict
from dataclasses import dataclass
import re

@dataclass
class SimulationConfig:
    """Configuration de simulation"""
    vdd: float = 1.8
    temp: float = 27
    corner: str = "tt"
    cload: float = 10e-15  # 10fF (pas 1e-12!)
    trise: float = 100e-12
    tfall: float = 100e-12

@dataclass
class TransitionTest:
    """Définit un test de transition"""
    name: str
    input_signals: Dict[str, str]
    measures: List[str]

class NetlistGenerator:
    """Génère des netlists SPICE pour caractérisation"""

    def __init__(self, pdk_manager, output_dir: Optional[Path] = None):
        self.pdk = pdk_manager
        
        if output_dir is None:
            self.output_dir = self.pdk.pdk_root / "libs.tech" / "ngspice"
        else:
            self.output_dir = Path(output_dir)
        
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.lib_spice = self.pdk.pdk_root / "libs.ref" / "sky130_fd_sc_hd" / "spice" / "sky130_fd_sc_hd.spice"

    def _parse_transition(self, signal: str) -> Tuple[str, str]:
        """Parse une transition '0→1' ou '1'"""
        if "→" in signal:
            parts = signal.split("→")
            if parts[0] == "0" and parts[1] == "1":
                return ("rise", "0")
            elif parts[0] == "1" and parts[1] == "0":
                return ("fall", "1")
        return ("static", signal)

    def generate_delay_netlist(
        self,
        cell_name: str,
        config: SimulationConfig = SimulationConfig(),
        transitions: Optional[List[TransitionTest]] = None
    ) -> Path:
        """Génère une netlist de caractérisation des délais"""
        
        output_file = self.output_dir / f"{cell_name}_delay.spice"
        
        if transitions is None:
            transitions = self._generate_default_transitions(cell_name)
        
        ports_info = self._get_cell_ports(cell_name)
        input_pins = ports_info['input_list']
        output_pin = ports_info['output']
        all_ports_ordered = ports_info['all_ports']
        
        netlist_lines = [
            f"* Delay Characterization: {cell_name}",
            f"* Generated by NetlistGenerator",
            f"* Corner: {config.corner}, VDD={config.vdd}V, Temp={config.temp}°C",
            "",
            "* ===== CONVERGENCE OPTIONS =====",
            ".option reltol=1e-3",
            ".option abstol=1e-12",
            ".option vntol=1e-6",
            ".option gmin=1e-15",
            ".option method=gear",
            "",
            "* ===== PDK LIBRARY =====",
            f".lib sky130.lib.spice {config.corner}",
            "",
            "* ===== CELL LIBRARY =====",
            f".include {self.lib_spice}",
            "",
            "* ===== PARAMETERS =====",
            f".param SUPPLY={config.vdd}",
            f".param CLOAD={config.cload}",
            f".param trise={config.trise}",
            f".param tfall={config.tfall}",
            "",
            "* Temperature",
            f".temp {config.temp}",
            "",
            "* Power supplies",
            "VVDD VPWR 0 DC {SUPPLY}",
            "VVSS VGND 0 DC 0",
            "VVPB VPB 0 DC {SUPPLY}",
            "VVNB VNB 0 DC 0",
            "",
        ]
        
        # Condition initiale
        first_test = transitions[0]
        initial_states = {}
        
        for pin in input_pins:
            if pin in first_test.input_signals:
                trans_type, initial = self._parse_transition(first_test.input_signals[pin])
                initial_states[pin] = "0" if trans_type == "rise" else initial
            else:
                initial_states[pin] = "0"
        
        netlist_lines.append("* Initial conditions for convergence")
        for pin, value in initial_states.items():
            voltage = "{SUPPLY}" if value == "1" else "0"
            netlist_lines.append(f".ic V({pin})={voltage}")
        
        # Instanciation DUT
        dut_connections = []
        for port in all_ports_ordered:
            p_upper = port.upper()
            if p_upper in ['VPWR', 'VDD']:
                dut_connections.append('VPWR')
            elif p_upper in ['VGND', 'VSS']:
                dut_connections.append('VGND')
            elif p_upper == 'VPB':
                dut_connections.append('VPB')
            elif p_upper == 'VNB':
                dut_connections.append('VNB')
            else:
                dut_connections.append(port)
        
        netlist_lines.extend([
            "",
            "* Device Under Test",
            f"XCELL {' '.join(dut_connections)} {cell_name}",
            "",
            "* Output load",
            f"CL {output_pin} 0 {{CLOAD}}",
            "",
        ])
        
        # PWL
        test_duration = 2e-9
        settling_time = 1e-9
        
        pin_states = {pin: 0.0 for pin in input_pins}
        pwl_data = {pin: [(0, 0.0)] for pin in input_pins}
        
        for test_idx, test in enumerate(transitions):
            test_start = test_idx * (test_duration + settling_time)
            transition_time = test_start + 0.5e-9
            
            for pin in input_pins:
                signal = test.input_signals.get(pin, None)
                if signal is None:
                    continue
                
                trans_type, target = self._parse_transition(signal)
                target_voltage = float(target) * config.vdd
                
                if trans_type == "static":
                    if pin_states[pin] != target_voltage:
                        pwl_data[pin].append((test_start, pin_states[pin]))
                        pwl_data[pin].append((test_start + 1e-12, target_voltage))
                        pin_states[pin] = target_voltage
                
                elif trans_type == "rise":
                    if pin_states[pin] != 0:
                        pwl_data[pin].append((test_start, pin_states[pin]))
                        pwl_data[pin].append((test_start + 1e-12, 0.0))
                    
                    pwl_data[pin].append((transition_time, 0.0))
                    pwl_data[pin].append((transition_time + config.trise, config.vdd))
                    pin_states[pin] = config.vdd
                
                elif trans_type == "fall":
                    if pin_states[pin] != config.vdd:
                        pwl_data[pin].append((test_start, pin_states[pin]))
                        pwl_data[pin].append((test_start + 1e-12, config.vdd))
                    
                    pwl_data[pin].append((transition_time, config.vdd))
                    pwl_data[pin].append((transition_time + config.tfall, 0.0))
                    pin_states[pin] = 0.0
            
            test_end = test_start + test_duration
            for pin in input_pins:
                pwl_data[pin].append((test_end, pin_states[pin]))
        
        # Sources PWL
        netlist_lines.append("* Input sources")
        for pin in input_pins:
            pwl_str = " ".join([f"{t*1e9}n {v}" for t, v in pwl_data[pin]])
            netlist_lines.append(f"V{pin} {pin.lower()} 0 PWL({pwl_str})")
        
        netlist_lines.append("")
        
        # Mesures avec FROM/TO
        threshold = config.vdd / 2
        
        for test_idx, test in enumerate(transitions):
            t_start = test_idx * (test_duration + settling_time)
            t_end = t_start + test_duration
            
            netlist_lines.append(f"* Test {test_idx + 1}: {test.name}")
            
            for measure in test.measures:
                adapted_measure = measure.replace("{SUPPLY/2}", str(threshold))
                adapted_measure += f" FROM={t_start} TO={t_end}"
                netlist_lines.append(adapted_measure)
            
            netlist_lines.append("")
        
        # Simulation
        total_time = len(transitions) * (test_duration + settling_time)
        netlist_lines.extend([
            f"* Transient analysis",
            f".tran 1p {total_time} UIC",
            "",
            ".control",
            "run",
            ".endc",
            "",
            ".end"
        ])
        
        output_file.write_text("\n".join(netlist_lines))
        return output_file

    def _safe_add(self, pts: List[Tuple[float, float]], t: float, v: float):
        """Ajoute un point PWL si timestamp croissant"""
        if not pts or pts[-1][0] < t:
            pts.append((t, v))

    def _get_cell_ports(self, cell_name: str) -> dict:
        """Extrait les ports d'une cellule"""
        with open(self.lib_spice, 'r') as f:
            lines = f.readlines()
        
        in_cell = False
        ports_lines = []
        
        for line in lines:
            line = line.strip()
            if line.lower().startswith(f'.subckt {cell_name.lower()}'):
                in_cell = True
                parts = line.split(maxsplit=2)
                if len(parts) > 2:
                    ports_lines.append(parts[2])
                continue
            if in_cell and line.startswith('+'):
                ports_lines.append(line[1:].strip())
                continue
            if in_cell:
                break
        
        if not ports_lines:
            raise ValueError(f"Cellule {cell_name} introuvable")
        
        ports_text = ' '.join(ports_lines)
        all_ports = ports_text.split()
        
        power_ports = {'VPWR', 'VGND', 'VPB', 'VNB', 'VDD', 'VSS'}
        signal_ports = [p for p in all_ports if p.upper() not in power_ports]
        
        output_port = signal_ports[-1]
        input_ports = signal_ports[:-1]
        
        cell_lower = cell_name.lower()
        if any(gate in cell_lower for gate in ['buf', 'and', 'or', 'xor']):
            if 'X' in all_ports and 'Y' not in signal_ports:
                output_port = 'X'
        
        return {
            'inputs': ' '.join(input_ports),
            'output': output_port,
            'all_ports': all_ports,
            'input_list': input_ports
        }

    def _generate_default_transitions(self, cell_name: str) -> List[TransitionTest]:
        """Génère les tests par défaut"""
        cell_lower = cell_name.lower()
        
        try:
            ports = self._get_cell_ports(cell_name)
            inputs = ports['input_list']
            output = ports['output']
        except:
            return []
        
        # 1 entrée
        if len(inputs) == 1:
            inp = inputs[0]
            
            if 'inv' in cell_lower:
                return [
                    TransitionTest(
                        name=f"{inp}: 0→1 → {output}: 1→0 (tphl)",
                        input_signals={inp: "0→1"},
                        measures=[f".meas tran tphl TRIG v({inp.lower()}) VAL='{{SUPPLY/2}}' RISE=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' FALL=1"]
                    ),
                    TransitionTest(
                        name=f"{inp}: 1→0 → {output}: 0→1 (tplh)",
                        input_signals={inp: "1→0"},
                        measures=[f".meas tran tplh TRIG v({inp.lower()}) VAL='{{SUPPLY/2}}' FALL=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' RISE=1"]
                    )
                ]
            
            elif 'buf' in cell_lower:
                return [
                    TransitionTest(
                        name=f"{inp}: 0→1 → {output}: 0→1 (tplh)",
                        input_signals={inp: "0→1"},
                        measures=[f".meas tran tplh TRIG v({inp.lower()}) VAL='{{SUPPLY/2}}' RISE=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' RISE=1"]
                    ),
                    TransitionTest(
                        name=f"{inp}: 1→0 → {output}: 1→0 (tphl)",
                        input_signals={inp: "1→0"},
                        measures=[f".meas tran tphl TRIG v({inp.lower()}) VAL='{{SUPPLY/2}}' FALL=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' FALL=1"]
                    )
                ]
        
        # 2 entrées
        elif len(inputs) == 2:
            a, b = inputs[0], inputs[1]
            
            if 'nand' in cell_lower:
                return [
                    TransitionTest(
                        name=f"{a}: 0→1, {b}=1 → {output}: 1→0 (tphl)",
                        input_signals={a: "0→1", b: "1"},
                        measures=[f".meas tran tphl TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' RISE=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' FALL=1"]
                    ),
                    TransitionTest(
                        name=f"{a}: 1→0, {b}=1 → {output}: 0→1 (tplh)",
                        input_signals={a: "1→0", b: "1"},
                        measures=[f".meas tran tplh TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' FALL=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' RISE=1"]
                    )
                ]
            
            elif 'nor' in cell_lower:
                return [
                    TransitionTest(
                        name=f"{a}: 0→1, {b}=0 → {output}: 1→0 (tphl)",
                        input_signals={a: "0→1", b: "0"},
                        measures=[f".meas tran tphl TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' RISE=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' FALL=1"]
                    ),
                    TransitionTest(
                        name=f"{a}: 1→0, {b}=0 → {output}: 0→1 (tplh)",
                        input_signals={a: "1→0", b: "0"},
                        measures=[f".meas tran tplh TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' FALL=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' RISE=1"]
                    )
                ]
            
            elif 'and' in cell_lower and 'nand' not in cell_lower:
                return [
                    TransitionTest(
                        name=f"{a}: 0→1, {b}=1 → {output}: 0→1 (tplh)",
                        input_signals={a: "0→1", b: "1"},
                        measures=[f".meas tran tplh TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' RISE=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' RISE=1"]
                    ),
                    TransitionTest(
                        name=f"{a}: 1→0, {b}=1 → {output}: 1→0 (tphl)",
                        input_signals={a: "1→0", b: "1"},
                        measures=[f".meas tran tphl TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' FALL=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' FALL=1"]
                    )
                ]
            
            elif 'or' in cell_lower and 'nor' not in cell_lower and 'xor' not in cell_lower:
                return [
                    TransitionTest(
                        name=f"{a}: 0→1, {b}=0 → {output}: 0→1 (tplh)",
                        input_signals={a: "0→1", b: "0"},
                        measures=[f".meas tran tplh TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' RISE=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' RISE=1"]
                    ),
                    TransitionTest(
                        name=f"{a}: 1→0, {b}=0 → {output}: 1→0 (tphl)",
                        input_signals={a: "1→0", b: "0"},
                        measures=[f".meas tran tphl TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' FALL=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' FALL=1"]
                    )
                ]
            
            elif 'xor' in cell_lower:
                return [
                    TransitionTest(
                        name=f"{a}: 0→1, {b}=0 → {output}: 0→1 (tplh)",
                        input_signals={a: "0→1", b: "0"},
                        measures=[f".meas tran tplh TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' RISE=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' RISE=1"]
                    ),
                    TransitionTest(
                        name=f"{a}: 1→0, {b}=0 → {output}: 1→0 (tphl)",
                        input_signals={a: "1→0", b: "0"},
                        measures=[f".meas tran tphl TRIG v({a.lower()}) VAL='{{SUPPLY/2}}' FALL=1 TARG v({output.lower()}) VAL='{{SUPPLY/2}}' FALL=1"]
                    )
                ]
        
        raise NotImplementedError(f"Type de cellule non supporté: {cell_name}")
